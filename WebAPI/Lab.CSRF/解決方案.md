# CSRF 防護解決方案

## 問題描述
如何確保 Web API 只能被當前頁面呼叫，防止跨站請求偽造 (CSRF) 攻擊？

## 解決方案：Anti-Forgery Token 機制

### 1️⃣ 原理說明

使用 ASP.NET Core 內建的 **Anti-Forgery Token** 機制，透過以下方式確保 API 只能被當前頁面使用：

1. **雙重驗證機制**
   - 伺服器產生一個唯一的 Token
   - Token 同時儲存在 Cookie 和頁面中
   - 前端發送請求時，必須在 HTTP Header 中攜帶 Token
   - 伺服器驗證 Cookie 中的 Token 和 Header 中的 Token 是否匹配

2. **安全性保障**
   - ✅ 跨站請求無法讀取目標網站的 Token（受同源政策限制）
   - ✅ 即使惡意網站能觸發請求，也無法取得正確的 Token
   - ✅ Cookie 設定為 HttpOnly 和 Secure，防止 XSS 攻擊竊取

### 2️⃣ 實作步驟

#### **步驟 1: 設定 Anti-Forgery 服務**

在 `Program.cs` 中註冊服務：

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddAntiforgery(options =>
{
    options.HeaderName = "X-CSRF-TOKEN"; // 自訂 Header 名稱
});

var app = builder.Build();

app.UseAntiforgery(); // 啟用 Anti-Forgery 中介軟體
app.MapControllers();

app.Run();
```

#### **步驟 2: 建立 Token 產生端點**

建立 Controller 提供 Token：

```csharp
using Microsoft.AspNetCore.Antiforgery;
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class CsrfController : ControllerBase
{
    private readonly IAntiforgery _antiforgery;

    public CsrfController(IAntiforgery antiforgery)
    {
        _antiforgery = antiforgery;
    }

    [HttpGet("token")]
    [IgnoreAntiforgeryToken] // 此端點不需驗證 Token
    public IActionResult GetToken()
    {
        var tokens = _antiforgery.GetAndStoreTokens(HttpContext);
        return Ok(new { token = tokens.RequestToken });
    }

    [HttpPost("protected")]
    [ValidateAntiForgeryToken] // 驗證 Token
    public IActionResult ProtectedAction([FromBody] DataRequest request)
    {
        return Ok(new { 
            success = true, 
            message = "CSRF 驗證成功！", 
            data = request.Data 
        });
    }
}

public class DataRequest
{
    public string? Data { get; set; }
}
```

#### **步驟 3: 前端實作**

前端頁面取得 Token 並在請求中攜帶：

```javascript
let csrfToken = null;

// 1. 取得 Token
async function getToken() {
    const response = await fetch('/api/csrf/token', {
        method: 'GET',
        credentials: 'include' // 重要：包含 Cookie
    });
    
    const data = await response.json();
    csrfToken = data.token;
}

// 2. 呼叫受保護的 API
async function callProtectedApi() {
    const response = await fetch('/api/csrf/protected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-TOKEN': csrfToken // 在 Header 中攜帶 Token
        },
        credentials: 'include', // 重要：包含 Cookie
        body: JSON.stringify({ data: 'Hello CSRF!' })
    });
    
    const result = await response.json();
    console.log(result);
}
```

### 3️⃣ 運作流程

```
┌─────────────┐                    ┌─────────────┐
│   前端頁面   │                    │   Web API   │
└─────────────┘                    └─────────────┘
       │                                  │
       │ 1. GET /api/csrf/token          │
       │ ─────────────────────────────>  │
       │                                  │
       │ 2. Token + Cookie (Set-Cookie)  │
       │ <─────────────────────────────  │
       │                                  │
       │ 3. POST /api/csrf/protected     │
       │    Header: X-CSRF-TOKEN         │
       │    Cookie: .AspNetCore.Antiforgery│
       │ ─────────────────────────────>  │
       │                                  │
       │ 4. 驗證 Token 是否匹配          │
       │                                  │ ✅ 驗證成功
       │ 5. 回傳結果                     │
       │ <─────────────────────────────  │
```

### 4️⃣ 為什麼可以防止跨站攻擊？

| 情境 | Cookie | Token (Header) | 結果 |
|------|--------|----------------|------|
| **正常請求** (來自本站) | ✅ 有 | ✅ 有 | ✅ 通過驗證 |
| **跨站攻擊** (來自惡意網站) | ✅ 有* | ❌ 無 | ❌ 驗證失敗 |

> *註：瀏覽器會自動攜帶 Cookie，但惡意網站無法讀取或設定 Header 中的 Token（受 CORS 和同源政策限制）

### 5️⃣ 其他防護方法

除了 Anti-Forgery Token，還有以下輔助方法：

#### **方法 1: SameSite Cookie**
```csharp
builder.Services.AddAntiforgery(options =>
{
    options.Cookie.SameSite = SameSiteMode.Strict; // 或 Lax
    options.Cookie.HttpOnly = true;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
});
```

#### **方法 2: Referer/Origin Header 驗證**
```csharp
public class ValidateRefererAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        var referer = context.HttpContext.Request.Headers["Referer"].ToString();
        var allowedDomain = "https://yourdomain.com";
        
        if (!referer.StartsWith(allowedDomain))
        {
            context.Result = new BadRequestResult();
        }
    }
}
```

#### **方法 3: Custom Header 驗證**
```csharp
public class ValidateCustomHeaderAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.HttpContext.Request.Headers.ContainsKey("X-Requested-With"))
        {
            context.Result = new BadRequestResult();
        }
    }
}
```

### 6️⃣ 最佳實踐建議

1. **主要防護**：使用 Anti-Forgery Token
2. **輔助防護**：搭配 SameSite Cookie
3. **HTTPS Only**：生產環境必須使用 HTTPS
4. **Token 過期**：設定合理的 Token 有效期限
5. **敏感操作**：所有修改資料的操作（POST/PUT/DELETE）都應啟用驗證

### 7️⃣ 測試方式

**正常流程測試：**
```bash
# 1. 取得 Token
curl -c cookies.txt http://localhost:5073/api/csrf/token

# 2. 使用 Token 呼叫 API (應成功)
curl -b cookies.txt -H "X-CSRF-TOKEN: <token>" \
     -H "Content-Type: application/json" \
     -d '{"data":"test"}' \
     http://localhost:5073/api/csrf/protected
```

**異常流程測試：**
```bash
# 不帶 Token 呼叫 API (應失敗 400)
curl -b cookies.txt \
     -H "Content-Type: application/json" \
     -d '{"data":"test"}' \
     http://localhost:5073/api/csrf/protected
```

### 8️⃣ 專案結構

```
Lab.CSRF.WebApi/
├── Controllers/
│   └── CsrfController.cs        # Token 產生與受保護的 API
├── wwwroot/
│   └── index.html                # 測試頁面
├── Program.cs                    # Anti-Forgery 設定
└── Lab.CSRF.WebApi.csproj
```

## 總結

使用 ASP.NET Core 的 Anti-Forgery Token 機制，能有效確保 API 只能被當前頁面呼叫，防止跨站請求偽造攻擊。此方案符合 OWASP 安全建議，易於實作且維護成本低。
