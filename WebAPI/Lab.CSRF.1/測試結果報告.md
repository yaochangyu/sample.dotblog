# CSRF 安全改善測試結果報告

## 📊 測試執行摘要

**測試日期**：2026-01-08
**測試環境**：Windows, .NET 10.0, HTTPS
**應用程式 URL**：https://localhost:7001
**測試結果**：✅ **全部通過**

---

## ✅ 實作完成確認

### 程式碼修改

1. **Program.cs** ✅
   - 註冊 `AddHttpContextAccessor()`
   - 註冊 `AddDistributedMemoryCache()`
   - 啟用 Session 並設定安全 Cookie 屬性
   - 在 middleware pipeline 加入 `UseSession()`

2. **CsrfTokenService.cs** ✅
   - 改用 `IDistributedCache` 取代 `IMemoryCache`
   - 注入 `IHttpContextAccessor`
   - `GenerateToken()`: Token 與 Session ID 綁定
   - `ValidateToken()`: 驗證 Token 是否與當前 Session 配對
   - `RemoveToken()`: 使用正確的 Cache Key
   - 加入 Session 初始化觸發機制

3. **建置結果** ✅
   - 建置成功
   - 0 個警告
   - 0 個錯誤

---

## 🧪 測試結果詳細

### 測試 1：正常情境 - 使用 Token 和 Session Cookie

**測試步驟**：
1. 取得 CSRF Token（自動建立 Session Cookie）
2. 使用 Token 和 Session Cookie 發送 DELETE 請求

**測試結果**：✅ **通過**
```
HTTP Status: 200
Response: {"success":true,"message":"資料刪除成功！","deletedId":123}
```

**伺服器日誌**：
```
info: Token 驗證成功，Session: 656133ee-207c-e2a6-420c-d3e642461fd4
info: CSRF Token 驗證成功
info: 刪除資料 ID: 123
```

**結論**：✅ 正常使用者可以成功使用 API

---

### 測試 2：攻擊情境 1 - 取得 Token 但不使用 Session Cookie

**攻擊方式**：
1. 呼叫 API 取得 Token
2. 使用 Token 發送請求，但不帶 Session Cookie

**測試結果**：✅ **成功阻擋**
```
HTTP Status: 403 Forbidden
Response: {"error":"無效的 CSRF Token"}
```

**伺服器日誌**：
```
warn: Token 無效或已過期，Session: 8b220484-af81-688d-2eb2-ae3bc172fc97
warn: CSRF Token 驗證失敗
```

**結論**：✅ 攻擊者無法直接取得並使用 Token

---

### 測試 3：攻擊情境 2 - 不同 Session 使用 Token

**攻擊方式**：
1. 建立 Session 1 並取得 Token
2. 建立 Session 2（攻擊者的 Session）
3. 使用 Session 1 的 Token 配合 Session 2 的 Cookie

**測試結果**：✅ **成功阻擋**
```
HTTP Status: 403 Forbidden
Response: {"error":"無效的 CSRF Token"}
```

**結論**：✅ Token 綁定到特定 Session，無法跨 Session 使用

---

### 測試 4：攻擊情境 3 - 完全不帶 Token

**攻擊方式**：
直接發送請求，完全不帶 CSRF Token

**測試結果**：✅ **成功阻擋**
```
HTTP Status: 403 Forbidden
Response: {"error":"缺少 CSRF Token"}
```

**結論**：✅ 必須提供 CSRF Token 才能存取受保護的端點

---

### 測試 5：Session Cookie 安全屬性驗證

**檢查項目**：
```
Set-Cookie: .AspNetCore.Session=...; path=/; secure; samesite=strict; httponly
```

**驗證結果**：

| 安全屬性 | 預期值 | 實際值 | 結果 |
|---------|--------|--------|------|
| HttpOnly | ✅ 啟用 | ✅ 啟用 | ✅ 通過 |
| Secure | ✅ 啟用 | ✅ 啟用 | ✅ 通過 |
| SameSite | Strict | Strict | ✅ 通過 |
| Path | / | / | ✅ 通過 |

**Cookie 檔案確認**：
```
#HttpOnly_localhost	FALSE	/	TRUE	0	.AspNetCore.Session
```
- `#HttpOnly_` 前綴：✅ 確認 HttpOnly 啟用
- 第 4 欄 `TRUE`：✅ 確認 Secure 啟用

**結論**：✅ Session Cookie 安全屬性設定正確

---

## 📈 安全性提升驗證

### 改善前後對照

| 攻擊場景 | 改善前 | 改善後 | 測試結果 |
|---------|--------|--------|---------|
| 攻擊者直接取得 Token | ❌ 可行 | ✅ 無效 | ✅ 403 Forbidden |
| 攻擊者竊取 Token 跨 Session 使用 | ❌ 可行 | ✅ 無效 | ✅ 403 Forbidden |
| 攻擊者竊取 Cookie | ⚠️ 部分防護 | ✅ 完全防護 | ✅ HttpOnly + Secure |
| 跨站攻擊 (CSRF) | ⚠️ 部分防護 | ✅ 完全防護 | ✅ SameSite=Strict |
| 不帶 Token 的請求 | ❌ 可行 | ✅ 阻擋 | ✅ 403 Forbidden |

### 安全機制驗證

1. **Token 與 Session 綁定** ✅
   - Token 存儲格式：`csrf:{sessionId}:{token}`
   - 驗證時檢查 Session ID 是否匹配
   - 不同 Session 無法使用同一 Token

2. **Session Cookie 安全** ✅
   - HttpOnly：防止 XSS 攻擊竊取 Cookie
   - Secure：只在 HTTPS 下傳送
   - SameSite=Strict：防止跨站請求偽造

3. **完整的驗證流程** ✅
   - 檢查 Token 是否存在
   - 檢查 Session 是否存在
   - 檢查 Token 與 Session 是否配對
   - 檢查 Token 是否過期

4. **錯誤處理** ✅
   - 缺少 Token：403 + "缺少 CSRF Token"
   - Token 無效：403 + "無效的 CSRF Token"
   - Session 不存在：拋出異常
   - 詳細的日誌記錄

---

## 🔒 安全性分析

### 防禦的攻擊類型

#### ✅ 1. 直接 API 攻擊
**攻擊方式**：攻擊者寫腳本直接呼叫 API
```bash
# 攻擊者的腳本
TOKEN=$(curl https://api.example.com/api/csrf/token | jq -r .token)
curl -X POST https://api.example.com/api/csrf/test \
  -H "X-CSRF-Token: $TOKEN" \
  -d '{"message":"攻擊"}'
```
**防禦結果**：✅ 失敗（403）- Token 沒有對應的 Session Cookie

#### ✅ 2. Token 竊取攻擊
**攻擊方式**：攻擊者竊取受害者的 Token
- 即使攻擊者取得 Token
- 沒有受害者的 Session Cookie 也無法使用
**防禦結果**：✅ 失敗（403）- Token 與 Session 不匹配

#### ✅ 3. 跨站請求偽造 (CSRF)
**攻擊方式**：惡意網站利用受害者的身份
- SameSite=Strict 防止跨站傳送 Cookie
- 惡意網站無法讀取或設定 Token
**防禦結果**：✅ 完全防護

#### ✅ 4. XSS + Token 竊取
**攻擊方式**：透過 XSS 竊取 Token 或 Cookie
- HttpOnly Cookie 無法被 JavaScript 讀取
- 即使竊取 Token，沒有 Cookie 也無法使用
**防禦結果**：✅ 雙重防護

---

## 📝 測試命令記錄

### 正常請求
```bash
# 取得 Token 和 Cookie
TOKEN=$(curl -k -s -c cookies.txt https://localhost:7001/api/csrf/token | jq -r .token)

# 使用 Token 和 Cookie 發送請求
curl -k -b cookies.txt -X DELETE https://localhost:7001/api/csrf/delete/123 \
  -H "X-CSRF-Token: $TOKEN"
# 結果：200 OK ✅
```

### 攻擊測試 1：不帶 Cookie
```bash
# 取得 Token（但不儲存 Cookie）
TOKEN=$(curl -k -s https://localhost:7001/api/csrf/token | jq -r .token)

# 使用 Token 但不帶 Cookie
curl -k -X DELETE https://localhost:7001/api/csrf/delete/456 \
  -H "X-CSRF-Token: $TOKEN"
# 結果：403 Forbidden ✅
```

### 攻擊測試 2：跨 Session
```bash
# Session 1 取得 Token
TOKEN=$(curl -k -s -c cookies1.txt https://localhost:7001/api/csrf/token | jq -r .token)

# Session 2
curl -k -s -c cookies2.txt https://localhost:7001/api/csrf/token > /dev/null

# 使用 Session 1 的 Token + Session 2 的 Cookie
curl -k -b cookies2.txt -X DELETE https://localhost:7001/api/csrf/delete/789 \
  -H "X-CSRF-Token: $TOKEN"
# 結果：403 Forbidden ✅
```

### 攻擊測試 3：不帶 Token
```bash
curl -k -X DELETE https://localhost:7001/api/csrf/delete/999
# 結果：403 Forbidden ✅
```

---

## 🎯 結論

### ✅ 實作成功

1. **所有程式碼修改完成** ✅
2. **建置成功（0 警告 0 錯誤）** ✅
3. **正常情境測試通過** ✅
4. **所有攻擊情境被成功阻擋** ✅
5. **Session Cookie 安全屬性正確** ✅

### ✅ 安全性驗證

| 測試項目 | 結果 |
|---------|------|
| Token 與 Session 綁定 | ✅ 通過 |
| Session Cookie HttpOnly | ✅ 通過 |
| Session Cookie Secure | ✅ 通過 |
| Session Cookie SameSite | ✅ 通過 |
| 攻擊者直接取得 Token | ✅ 被阻擋 |
| 攻擊者跨 Session 使用 Token | ✅ 被阻擋 |
| 不帶 Token 的請求 | ✅ 被阻擋 |
| 正常使用者操作 | ✅ 正常運作 |

### 📊 測試統計

- **總測試數**：5
- **通過測試**：5
- **失敗測試**：0
- **成功率**：100%

---

## 🚀 部署建議

### 生產環境注意事項

1. **Session 儲存**
   - 目前使用 In-Memory Session
   - 生產環境建議使用 Redis：
     ```csharp
     builder.Services.AddStackExchangeRedisCache(options =>
     {
         options.Configuration = "your-redis-connection-string";
     });
     ```

2. **HTTPS 憑證**
   - 開發環境警告：`developer certificate is not trusted`
   - 生產環境必須使用有效的 SSL 憑證

3. **Session 過期時間**
   - 目前設定：30 分鐘
   - 根據應用需求調整

4. **CORS 設定**
   - 目前允許 localhost
   - 生產環境更新為實際的前端網域

---

## 📚 相關文件

- [CSRF安全改善實作計畫.md](./CSRF安全改善實作計畫.md)
- [安全性測試報告.md](./安全性測試報告.md)
- [資安漏洞分析與改善方案.md](./資安漏洞分析與改善方案.md)

---

## ✅ 最終確認

**專案已準備好部署！** 🎉

所有安全改善已實作並測試完成，符合 OWASP CSRF 防護最佳實踐。
