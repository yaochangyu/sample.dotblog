# 用 Microsoft.Extensions.Http.Resilience 實作 Retry：效能與 Polly 的比較

祕訣無它，唯勤而已；唯有不斷學習，才能成長。  
這篇文章要分享我最近在研究 **Microsoft.Extensions.Http.Resilience** 與 **Microsoft.Extensions.Http.Polly** 的心得，特別是 **Retry 策略** 的使用方式與效能比較。

在 .NET 9 之後，微軟官方推出了新的 **Resilience Handler**，它內建在 `Microsoft.Extensions.Http.Resilience` 套件中，不再需要額外安裝 Polly 套件就能使用 Retry、Circuit Breaker、Timeout 等彈性策略。這對開發者來說是一個重要的轉折點。

---

## 開發環境
- Windows 11 Pro / Ubuntu 24.04 (WSL2)
- .NET 9.0.4
- BenchmarkDotNet v0.15.4
- 測試 API: `http://localhost:5068/api/members`

---

## Microsoft.Extensions.Http.Resilience 使用方式

Resilience 套件提供了 **標準化的彈性處理器**，只要一行 `.AddStandardResilienceHandler()` 就能套用官方建議的 Retry、Timeout、Circuit Breaker 策略。

```csharp
services.AddHttpClient("resilience", client =>
{
    client.BaseAddress = new Uri("http://localhost:5068");
})
.AddStandardResilienceHandler();
```

如果要自訂 Retry 策略，可以用 `AddResilienceHandler`：

```csharp
services.AddHttpClient("resilience-retry", client =>
{
    client.BaseAddress = new Uri("http://localhost:5068");
})
.AddResilienceHandler("retry", builder =>
{
    builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>
    {
        MaxRetryAttempts = 3,
        BackoffType = DelayBackoffType.Exponential,
        Delay = TimeSpan.FromSeconds(1),
        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()
            .HandleResult(r => !r.IsSuccessStatusCode)
            .Handle<HttpRequestException>()
    });
});
```

這裡的 API 設計和 **Polly V8** 幾乎一樣，因為 Resilience Handler 本身就是基於 Polly V8 的 Resilience Pipeline。

---

## Microsoft.Extensions.Http.Polly 使用方式

在 Resilience Handler 出現之前，我們都是透過 **Microsoft.Extensions.Http.Polly** 來整合 Polly 策略。  
以下是最常見的 Retry 寫法：

```csharp
services.AddHttpClient("polly", client =>
{
    client.BaseAddress = new Uri("http://localhost:5068");
})
.AddPolicyHandler(HttpPolicyExtensions
    .HandleTransientHttpError()
    .WaitAndRetryAsync(
        retryCount: 3,
        sleepDurationProvider: retryAttempt =>
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))));
```

這種寫法依賴 **Polly V7** 的 API，屬於舊式的 Policy Chain。  
如果升級到 **Polly V8**，則可以改用 Resilience Pipeline 的方式，語法就會和 `Microsoft.Extensions.Http.Resilience` 幾乎一致。

---

## 效能比較：Polly vs Resilience

我用 BenchmarkDotNet 做了壓測，結果如下（詳細數據來自 [FIXED_BENCHMARK_RESULTS.md] 與 [POLLY_V8_介紹.md]）：

| 方法 | 平均時間 | 標準差 | 記憶體分配 |
|------|---------|--------|-----------|
| **StandardHttpClient** | 158.0 μs | 6.68 μs | 3.31 KB |
| **Polly V8** | 171.9 μs | 8.32 μs | 4.95 KB |
| **Resilience** | 174.7 μs | 8.46 μs | 6.48 KB |
| **Polly V7** | 204.3 μs | 33.64 μs | 4.46 KB |

### 關鍵觀察
1. **Polly V8** 比 **Polly V7** 快了 **15.9%**，而且穩定性大幅提升（標準差降低 75%）。
2. **Resilience Handler** 的效能和 Polly V8 幾乎一樣，差異僅 **2.8%**，但記憶體使用稍高。
3. **Polly V7** 不僅慢，變異性也大，已經不建議使用。

---

## 架構差異

### Polly V7
```csharp
var retryPolicy = Policy
    .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
    .WaitAndRetryAsync(3, retryAttempt =>
        TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));

var circuitBreakerPolicy = Policy
    .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
    .CircuitBreakerAsync(3, TimeSpan.FromSeconds(30));

var policyWrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
```

### Polly V8 / Resilience
```csharp
services.AddHttpClient("api")
.AddResilienceHandler("standard", builder =>
{
    builder
        .AddRetry(new RetryStrategyOptions<HttpResponseMessage>())
        .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage>())
        .AddTimeout(TimeSpan.FromSeconds(10));
});
```

可以看到，**Resilience Handler** 和 **Polly V8** 幾乎是同一套 API，差別只在於套件來源。

---

## 心得

- 如果你是 **新專案**，建議直接用 **Microsoft.Extensions.Http.Resilience**，因為它是官方推薦、長期維護的方案。
- 如果你已經在用 **Polly V8**，其實和 Resilience 幾乎一樣，差別只在於整合度。
- 如果還在用 **Polly V7**，強烈建議規劃遷移，因為效能與穩定性都落後太多。

---

## 範例程式碼位置
- [Polly V8 範例](https://github.com/App-vNext/Polly)
- [Resilience 官方文件](https://learn.microsoft.com/zh-tw/dotnet/core/resilience/http-resilience?tabs=dotnet-cli)

---

## 結論

- **Polly V8**：效能最佳，API 現代化。
- **Resilience Handler**：效能接近 Polly V8，整合度更高，官方推薦。
- **Polly V7**：效能差、變異性大，應該淘汰。

👉 我的建議：**新專案直接用 Resilience Handler，舊專案盡快升級到 Polly V8 或 Resilience。**

---

要不要我幫你畫一張 **Retry 策略的狀態圖**，像余小章文章裡常用的那種流程圖，讓整個 Retry 行為更直觀？