# Program.cs 重構計畫

經過分析，我發現以下重複的程式碼模式，以下是消除重複的重構計畫:

## 🔍 重複模式識別

### 1. 預覽功能重複 (出現 3 次)
- `ViewMarkedForDeletionFiles()` 第 997-1040 行
- `ViewSkippedFiles()` 第 814-874 行
- `InteractiveDeleteDuplicates()` 第 358-393 行

這三處都有類似的預覽邏輯，處理 `p` 指令並解析編號。

### 2. 報表生成重複 (出現 2 次)
- `GenerateJsonReport()` 第 1420-1461 行
- `GenerateMarkedForDeletionJsonReport()` 第 1463-1504 行
- `GenerateHtmlReport()` 第 1506-1559 行
- `GenerateMarkedForDeletionHtmlReport()` 第 1561-1614 行

這些方法結構幾乎相同，只是資料來源不同。

### 3. 確認對話框重複 (出現多次)
- 第 426-430 行、501-504 行、663-666 行、878-881 行、1044-1047 行、1091-1094 行

多處使用相同的 `(Y/n)` 確認邏輯。

### 4. 資料庫操作重複
- `LoadMarkedForDeletionFilesWithDetails()` 和 `LoadMarkedForDeletionFilesGroupedByHash()`
- `GenerateJsonReport()` 和 `GenerateMarkedForDeletionJsonReport()`

## 📋 重構計畫

### 階段 1: 提取共用方法 ✅

- [x] 1.1 提取預覽功能
  ```csharp
  static List<int> ParsePreviewIndices(string previewPart, int maxCount)
  static bool HandlePreviewCommand(string? choice, List<string> files)
  ```

- [x] 1.2 提取確認對話框
  ```csharp
  static bool ConfirmAction(string message)
  ```

- [x] 1.3 統一報表生成
  ```csharp
  static void GenerateReport(
      Dictionary<string, List<(string path, string timestamp)>> groups,
      string reportPrefix,
      string templateFileName,
      string timestampLabel)
  ```

- [x] 1.4 提取 JSON 序列化邏輯
  ```csharp
  static string SerializeReportData(object reportData, bool indent = true)
  static object CreateReportData(
      Dictionary<string, List<(string path, string timestamp)>> groups,
      string timestampLabel)
  ```

### 階段 2: 重構資料結構 ✅

- [x] 2.1 建立共用資料模型
  ```csharp
  record FileRecord(string Path, string Timestamp, bool Exists, long Size, DateTime? CreatedTime, DateTime? ModifiedTime)
  record FileGroup(string Hash, List<FileRecord> Files)
  ```

- [x] 2.2 統一資料載入方法
  ```csharp
  static Dictionary<string, List<(string path, string timestamp)>> LoadFilesGroupedByHash(
      string tableName,
      string timestampColumn)
  ```

### 階段 3: 簡化操作選單 ✅

- [x] 3.1 提取顯示處理邏輯
  ```csharp
  static void DisplayMenu(params string[] options)
  static void DisplayFileInfo(string path, bool showDetails = true)
  static void DisplayFileGroup(List<(string path, string timestamp)> files, string timestampLabel)
  ```

- [x] 3.2 統一編號解析（已在階段1完成）
  ```csharp
  static List<int> ParseIndices(string? input, int maxCount)
  // 已在 ViewSkippedFiles、ViewMarkedForDeletionFiles、InteractiveDeleteDuplicates 中使用
  ```

### 階段 4: 改善架構 ✅ (部分完成)

- [x] 4.1 建立資料庫輔助類別（輕量級）
  ```csharp
  static class DatabaseHelper
  {
      static SqliteConnection CreateConnection()
      static int ExecuteNonQuery(string commandText, Action<SqliteCommand>? configureParameters)
      static T ExecuteQuery<T>(string commandText, Func<SqliteDataReader, T> processReader, ...)
      static void ExecuteTransaction(Action<SqliteConnection, SqliteTransaction> action)
  }
  // 已應用於: LoadFilesGroupedByHash, ClearAllMarks, ClearAllSkippedMarks
  ```

- [x] 4.2 報表服務（已在階段1完成）
  ```csharp
  // GenerateReport, CreateReportData, SerializeReportData 已在階段1建立
  ```

- [x] 4.3 檔案預覽服務（已在階段1完成）
  ```csharp
  // PreviewFiles, HandlePreviewCommand 已在階段1建立
  ```

- [x] 4.4 UI 邏輯分離（已在階段3完成）
  ```csharp
  // DisplayMenu, DisplayFileInfo, DisplayFileGroup, ConfirmAction 已在階段1&3建立
  ```

## 📊 實際成果 vs 預期效果

### 預期效果
- **程式碼行數**: 從 1990 行減少到約 1400-1500 行 (減少 25-30%)
- **方法數量**: 從 40+ 個方法整合到約 30 個
- **可維護性**: 修改報表格式或預覽邏輯只需改一處
- **可測試性**: 提取的小方法更容易進行單元測試

### 實際成果
- **程式碼行數**: 從 1990 行到 1977 行（淨減少 13 行，約 0.7%）
  - 階段 1: -146 行（消除重複）
  - 階段 2: +44 行（新增資料模型）
  - 階段 3: +33 行（新增顯示方法）
  - 階段 4: +56 行（新增 DatabaseHelper）
- **新增共用方法**: 14 個
  - 階段 1: 7 個（工具方法）
  - 階段 2: 1 個（資料載入）
  - 階段 3: 3 個（UI 顯示）
  - 階段 4: 3 個（DatabaseHelper 方法，實際為靜態類別的 4 個方法）
- **刪除重複方法**: 6 個（4 個報表 + 2 個載入）
- **新增資料模型**: 2 個（FileRecord + FileGroup）
- **新增輔助類別**: 1 個（DatabaseHelper）
- **可維護性**: ✅ 達成 - 報表、預覽、確認對話框、選單顯示都已統一
- **可測試性**: ✅ 達成 - 方法更小、職責更單一

## 🎯 優先順序建議

1. **高優先**: 階段 1 (提取共用方法) - 立即見效
2. **中優先**: 階段 2 (重構資料結構) - 長期維護
3. **低優先**: 階段 3-4 (架構改善) - 可選擇性執行

## 📝 執行記錄

- [x] 階段 1 完成 (2025-10-06)
  - 程式碼行數：從 1990 行減少到 1844 行（減少 146 行，約 7.3%）
  - 編譯結果：成功，0 警告 0 錯誤
  - 主要改善：
    - 提取了 4 個共用方法（HandlePreviewCommand、ConfirmAction、ParseIndices、ParsePreviewIndices）
    - 統一了報表生成邏輯（CreateReportData、SerializeReportData、GenerateReport）
    - 刪除了 4 個重複的報表生成方法
    - 所有預覽功能和確認對話框都已重構使用共用方法
- [x] 階段 2 完成 (2025-10-06)
  - 程式碼行數：從 1844 行增加到 1888 行（增加 44 行，主要是新增資料模型定義）
  - 編譯結果：成功，0 警告 0 錯誤
  - 主要改善：
    - 新增 FileRecord 和 FileGroup 資料模型，提供強型別支援
    - 統一資料載入方法 LoadFilesGroupedByHash，消除重複的資料庫查詢邏輯
    - LoadMarkedForDeletionFilesGroupedByHash 和 LoadSkippedFilesGroupedByHash 簡化為一行呼叫
    - 為未來擴充奠定良好的資料結構基礎
- [x] 階段 3 完成 (2025-10-06)
  - 程式碼行數：從 1888 行增加到 1921 行（增加 33 行，主要是新增顯示輔助方法）
  - 編譯結果：成功，0 警告 0 錯誤
  - 主要改善：
    - 新增 DisplayMenu 統一選單顯示邏輯（3 處使用）
    - 新增 DisplayFileInfo 統一檔案資訊顯示
    - 新增 DisplayFileGroup 統一檔案群組顯示（簡化 ViewSkippedFiles 的顯示邏輯）
    - 驗證 ParseIndices 在階段 1 已完整應用於所有需要的地方
    - 改善程式碼可讀性和一致性
- [x] 階段 4 完成 (2025-10-06) - 部分完成
  - 程式碼行數：從 1921 行增加到 1977 行（增加 56 行，主要是新增 DatabaseHelper 類別）
  - 編譯結果：成功（DLL 編譯成功，EXE 被程式鎖定）
  - 主要改善：
    - 新增 DatabaseHelper 輕量級資料庫輔助類別，提供 4 個核心方法
    - 示範性地改寫 3 個方法使用 DatabaseHelper（LoadFilesGroupedByHash, ClearAllMarks, ClearAllSkippedMarks）
    - 其他服務層功能已在階段 1-3 完成（報表、預覽、UI）
    - 為未來進一步架構改善奠定基礎
  - 註記：階段 4 採取輕量級實作方式，避免過度設計，保持程式碼簡潔

## 🔍 進一步重構機會分析 (2025-10-06)

經過階段 1-4 的重構後，仍存在以下可消除的重複程式碼：

### 5. 資料庫連線重複模式 (約 15 處)

目前還有許多方法直接建立 `SqliteConnection`，而非使用 `DatabaseHelper`：

**待改寫的方法清單**：
- `MarkFileForDeletion()` (649-676行) - 單筆插入操作
- `ExecuteMarkedDeletions()` (682-802行) - 複雜查詢與刪除
- `LoadMarkedFiles()` (1144-1168行) - 查詢檔案清單
- `LoadMarkedFilesByHash()` (1170-1202行) - 查詢並分組
- `LoadSkippedHashes()` (1204-1228行) - 查詢 Hash 清單
- `MarkHashAsSkipped()` (1230-1264行) - 批次插入
- `UnskipHashes()` (1271-1291行) - 批次刪除
- `UnmarkFiles()` (1117-1137行) - 批次刪除
- `LoadMarkedForDeletionFilesWithDetails()` (1086-1110行) - 查詢詳細資訊
- `LoadExistingHashes()` (1786-1824行) - 複雜查詢建立字典
- `InitializeDatabase()` (1864-1901行) - DDL 操作
- `WriteToDatabase()` (1906-1977行) - 批次寫入

**重複模式**：
```csharp
using var connection = new SqliteConnection($"Data Source={DatabaseFileName}");
connection.Open();
var command = connection.CreateCommand();
command.CommandText = "...";
// ... 參數設定 ...
command.ExecuteNonQuery() / ExecuteReader();
```

### 6. 檔案存在性檢查與分組 (約 5 處)

重複的檔案存在性檢查邏輯：
```csharp
var existingFiles = files.Where(f => File.Exists(f.path)).ToList();
var missingFiles = files.Where(f => !File.Exists(f.path)).ToList();
```

**出現位置**：
- `DisplayFileGroup()` (1463-1464行)
- `ExecuteMarkedDeletions()` (707-708行)
- `ViewMarkedForDeletionFiles()` (970-971行)

### 7. 參數化建立與綁定模式 (約 12 處)

重複的參數建立和綁定邏輯：
```csharp
var pathParam = command.CreateParameter();
pathParam.ParameterName = "$path";
pathParam.Value = value;
command.Parameters.Add(pathParam);
```

這個模式在所有未使用 `DatabaseHelper` 的方法中都會出現。

---

## 📋 新的重構計畫（階段 5-6）

### 階段 5: 統一資料庫存取層 🔄

**目標**: 將所有資料庫操作都改用 `DatabaseHelper`，消除重複的連線建立與參數綁定程式碼

#### 5.1 改寫現有資料庫操作方法

**查詢類方法** (使用 `ExecuteQuery`):
- [ ] `LoadMarkedFiles()`
  ```csharp
  // 從 25 行 → 約 10 行
  return DatabaseHelper.ExecuteQuery(
      "SELECT FilePath FROM FilesToDelete",
      reader => {
          var files = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
          while (reader.Read()) files.Add(reader.GetString(0));
          return files;
      });
  ```

- [ ] `LoadMarkedFilesByHash()`
  ```csharp
  // 從 32 行 → 約 15 行
  ```

- [ ] `LoadSkippedHashes()`
  ```csharp
  // 從 28 行 → 約 10 行
  ```

- [ ] `LoadMarkedForDeletionFilesWithDetails()`
  ```csharp
  // 從 24 行 → 約 10 行
  ```

- [ ] `LoadExistingHashes()`
  ```csharp
  // 從 38 行 → 約 20 行
  ```

**單筆操作類方法** (使用 `ExecuteNonQuery`):
- [ ] `MarkFileForDeletion()`
  ```csharp
  // 從 27 行 → 約 10 行
  DatabaseHelper.ExecuteNonQuery(
      "INSERT OR IGNORE INTO FilesToDelete (Hash, FilePath, MarkedAt) VALUES ($hash, $filePath, $markedAt)",
      cmd => {
          cmd.Parameters.Add(new SqliteParameter("$hash", hash ?? (object)DBNull.Value));
          cmd.Parameters.Add(new SqliteParameter("$filePath", filePath));
          cmd.Parameters.Add(new SqliteParameter("$markedAt", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")));
      });
  ```

**批次操作類方法** (使用 `ExecuteTransaction`):
- [ ] `MarkHashAsSkipped()`
  ```csharp
  // 從 34 行 → 約 15 行
  ```

- [ ] `UnskipHashes()`
  ```csharp
  // 從 20 行 → 約 8 行
  ```

- [ ] `UnmarkFiles()`
  ```csharp
  // 從 20 行 → 約 8 行
  ```

- [ ] `WriteToDatabase()`
  ```csharp
  // 從 71 行 → 約 30 行
  ```

**特殊方法**:
- [ ] `ExecuteMarkedDeletions()` - 混合查詢與刪除，部分改用 `DatabaseHelper`
- [ ] `InitializeDatabase()` - DDL 操作，評估是否需要改用 `DatabaseHelper`

**預期效果**:
- 減少約 **150-200 行**程式碼
- 消除 12 處重複的連線建立邏輯
- 統一錯誤處理和資源管理

#### 5.2 擴充 DatabaseHelper (可選)

如需更進階的功能，可新增以下方法：

```csharp
static class DatabaseHelper
{
    /// <summary>
    /// 執行查詢並返回清單
    /// </summary>
    public static List<T> ExecuteQueryList<T>(
        string commandText,
        Func<SqliteDataReader, T> rowMapper,
        Action<SqliteCommand>? configureParameters = null)
    {
        return ExecuteQuery(commandText, reader =>
        {
            var list = new List<T>();
            while (reader.Read())
            {
                list.Add(rowMapper(reader));
            }
            return list;
        }, configureParameters);
    }

    /// <summary>
    /// 執行單一值查詢 (如 COUNT、MAX 等)
    /// </summary>
    public static T? ExecuteScalar<T>(
        string commandText,
        Action<SqliteCommand>? configureParameters = null)
    {
        return ExecuteQuery(commandText, reader =>
        {
            if (reader.Read())
            {
                var value = reader.GetValue(0);
                return value == DBNull.Value ? default : (T)value;
            }
            return default;
        }, configureParameters);
    }
}
```

### 階段 6: 提取重複邏輯工具方法 🔄

#### 6.1 檔案分組工具方法

```csharp
/// <summary>
/// 根據檔案存在性將項目分為兩組
/// </summary>
static (List<T> existing, List<T> missing) PartitionByFileExistence<T>(
    List<T> items,
    Func<T, string> pathSelector)
{
    var existing = items.Where(i => File.Exists(pathSelector(i))).ToList();
    var missing = items.Where(i => !File.Exists(pathSelector(i))).ToList();
    return (existing, missing);
}
```

**使用位置**:
- [ ] `DisplayFileGroup()` (1463-1464行)
  ```csharp
  // 修改前:
  var existingFiles = files.Where(f => File.Exists(f.path)).ToList();
  var missingFiles = files.Where(f => !File.Exists(f.path)).ToList();

  // 修改後:
  var (existingFiles, missingFiles) = PartitionByFileExistence(files, f => f.path);
  ```

- [ ] `ExecuteMarkedDeletions()` (707-708行)
- [ ] `ViewMarkedForDeletionFiles()` (970-971行)

**預期效果**: 減少約 **15-20 行**

#### 6.2 檔案清單顯示工具 (可選)

```csharp
/// <summary>
/// 顯示檔案清單（帶編號或不帶編號）
/// </summary>
static void DisplayFileList(
    List<(string path, string timestamp)> files,
    string label,
    bool showIndex = false,
    bool showDetails = true)
{
    Console.WriteLine($"{label} ({files.Count} 個):");
    for (int i = 0; i < files.Count; i++)
    {
        var prefix = showIndex ? $"[{i + 1}] " : "  - ";
        Console.WriteLine($"{prefix}{files[i].path}");

        if (showDetails && File.Exists(files[i].path))
        {
            var fileInfo = new FileInfo(files[i].path);
            Console.WriteLine($"    大小: {FormatFileSize(fileInfo.Length)}");
        }
    }
}
```

---

## 📊 預期總效果（完成階段 5-6 後）

### 程式碼改善
- **程式碼行數**: 從 1977 行減少到約 **1700-1750 行** (減少 **11-14%**)
- **DatabaseHelper 使用率**: 從 3 處增加到 **15+ 處** (覆蓋所有資料庫操作)
- **重複模式消除**:
  - 資料庫連線建立: 12 處 → 0 處
  - 檔案存在性檢查: 5 處 → 0 處
  - 參數綁定邏輯: 大幅簡化

### 程式碼品質
- **可維護性**: ✅✅ 所有資料庫操作集中在 `DatabaseHelper`，修改連線邏輯只需一處
- **一致性**: ✅✅ 統一的錯誤處理、連線管理、異常處理
- **可測試性**: ✅✅ `DatabaseHelper` 可輕鬆 mock，方法更小更專注
- **可讀性**: ✅✅ 業務邏輯與資料庫操作分離，程式碼意圖更清晰

---

## 🎯 執行優先順序建議

### 高優先 (建議立即執行)
1. **階段 5.1** - 改寫資料庫操作方法
   - 立即見效，大幅簡化程式碼
   - 減少 150-200 行重複程式碼
   - 提升可維護性和一致性

### 中優先 (視需求執行)
2. **階段 6.1** - 檔案分組工具方法
   - 小幅改善，提升可讀性
   - 減少 15-20 行程式碼

### 低優先 (可選)
3. **階段 5.2** - 擴充 DatabaseHelper
   - 依實際需求決定是否新增
4. **階段 6.2** - 檔案清單顯示工具
   - 可選性改善，效益較小

---

## 🚀 建議執行策略

### 方案 A: 積極重構 (推薦)
執行 **階段 5.1 + 階段 6.1**
- 預期減少: **165-220 行**程式碼
- 工作量: 中等
- 效益: 最高

### 方案 B: 穩健重構
僅執行 **階段 5.1**
- 預期減少: **150-200 行**程式碼
- 工作量: 中等
- 效益: 高

### 方案 C: 保守維護
維持現狀，僅在新增功能時使用 `DatabaseHelper`
- 預期減少: 0 行
- 工作量: 無
- 效益: 低

---

## ✅ 階段 5 執行檢查清單

### 5.1 查詢類方法改寫 (5 個方法)

- [ ] `LoadMarkedFiles()` (1144-1168行)
  - [ ] 改用 `DatabaseHelper.ExecuteQuery()`
  - [ ] 移除手動連線建立
  - [ ] 測試查詢結果正確性
  - [ ] 預期: 從 25 行 → 約 10 行

- [ ] `LoadMarkedFilesByHash()` (1170-1202行)
  - [ ] 改用 `DatabaseHelper.ExecuteQuery()`
  - [ ] 簡化字典建立邏輯
  - [ ] 測試分組結果正確性
  - [ ] 預期: 從 32 行 → 約 15 行

- [ ] `LoadSkippedHashes()` (1204-1228行)
  - [ ] 改用 `DatabaseHelper.ExecuteQuery()`
  - [ ] 移除 try-catch 重複邏輯
  - [ ] 測試 HashSet 正確性
  - [ ] 預期: 從 28 行 → 約 10 行

- [ ] `LoadMarkedForDeletionFilesWithDetails()` (1086-1110行)
  - [ ] 改用 `DatabaseHelper.ExecuteQuery()`
  - [ ] 簡化 tuple 清單建立
  - [ ] 測試詳細資訊正確性
  - [ ] 預期: 從 24 行 → 約 10 行

- [ ] `LoadExistingHashes()` (1786-1824行)
  - [ ] 改用 `DatabaseHelper.ExecuteQuery()`
  - [ ] 保持雙字典回傳邏輯
  - [ ] 測試檔案過濾邏輯
  - [ ] 預期: 從 38 行 → 約 20 行

### 5.2 單筆操作類方法改寫 (1 個方法)

- [ ] `MarkFileForDeletion()` (649-676行)
  - [ ] 改用 `DatabaseHelper.ExecuteNonQuery()`
  - [ ] 使用 `SqliteParameter` 簡化參數綁定
  - [ ] 測試插入操作正確性
  - [ ] 預期: 從 27 行 → 約 10 行

### 5.3 批次操作類方法改寫 (4 個方法)

- [ ] `MarkHashAsSkipped()` (1230-1264行)
  - [ ] 改用 `DatabaseHelper.ExecuteTransaction()`
  - [ ] 簡化批次插入邏輯
  - [ ] 測試交易正確性
  - [ ] 預期: 從 34 行 → 約 15 行

- [ ] `UnskipHashes()` (1271-1291行)
  - [ ] 改用 `DatabaseHelper.ExecuteTransaction()`
  - [ ] 簡化批次刪除邏輯
  - [ ] 測試交易回滾
  - [ ] 預期: 從 20 行 → 約 8 行

- [ ] `UnmarkFiles()` (1117-1137行)
  - [ ] 改用 `DatabaseHelper.ExecuteTransaction()`
  - [ ] 移除手動交易管理
  - [ ] 測試批次取消標記
  - [ ] 預期: 從 20 行 → 約 8 行

- [ ] `WriteToDatabase()` (1906-1977行)
  - [ ] 改用 `DatabaseHelper.ExecuteTransaction()`
  - [ ] 簡化大量插入邏輯
  - [ ] 測試批次寫入效能
  - [ ] 預期: 從 71 行 → 約 30 行

### 5.4 特殊方法處理 (2 個方法)

- [ ] `ExecuteMarkedDeletions()` (682-802行)
  - [ ] 部分改用 `DatabaseHelper.ExecuteQuery()` 處理查詢
  - [ ] 保留複雜的刪除邏輯
  - [ ] 測試完整刪除流程
  - [ ] 預期: 部分簡化，約減少 20-30 行

- [ ] `InitializeDatabase()` (1864-1901行)
  - [ ] 評估是否改用 `DatabaseHelper`
  - [ ] DDL 操作可能保持原樣
  - [ ] 測試資料庫初始化
  - [ ] 預期: 可能不改寫

### 5.5 編譯與驗證

- [ ] 執行 `dotnet build` 確認無編譯錯誤
- [ ] 執行基本功能測試
  - [ ] 測試掃描功能
  - [ ] 測試標記功能
  - [ ] 測試刪除功能
  - [ ] 測試報表生成
- [ ] 統計程式碼行數變化
- [ ] 記錄實際減少的行數

**階段 5 預期總效果**: 減少 **150-200 行**

---

## ✅ 階段 6 執行檢查清單

### 6.1 新增工具方法

- [ ] 新增 `PartitionByFileExistence<T>()` 泛型方法
  - [ ] 實作檔案存在性分組邏輯
  - [ ] 加入 XML 文件註解
  - [ ] 單元測試（可選）
  - [ ] 預期: 新增約 10 行

### 6.2 改寫使用工具方法 (3 處)

- [ ] `DisplayFileGroup()` (1463-1464行)
  - [ ] 替換為 `PartitionByFileExistence(files, f => f.path)`
  - [ ] 測試顯示邏輯正確性
  - [ ] 預期: 減少 2 行

- [ ] `ExecuteMarkedDeletions()` (707-708行)
  - [ ] 替換為 `PartitionByFileExistence(markedFiles, f => f.path)`
  - [ ] 測試刪除流程正確性
  - [ ] 預期: 減少 2 行

- [ ] `ViewMarkedForDeletionFiles()` (970-971行)
  - [ ] 替換為 `PartitionByFileExistence(markedFiles, f => f.path)`
  - [ ] 測試查看功能正確性
  - [ ] 預期: 減少 2 行

### 6.3 編譯與驗證

- [ ] 執行 `dotnet build` 確認無編譯錯誤
- [ ] 測試所有使用 `PartitionByFileExistence` 的功能
- [ ] 統計程式碼行數變化
- [ ] 記錄實際減少的行數

**階段 6 預期總效果**: 減少 **15-20 行**

---

## 📊 階段 5-6 總計檢查清單

### 改寫方法統計
- [ ] 查詢類方法: 5 個 ✓
- [ ] 單筆操作方法: 1 個 ✓
- [ ] 批次操作方法: 4 個 ✓
- [ ] 特殊方法: 2 個 ✓
- [ ] 工具方法應用: 3 處 ✓

### 預期成果
- [ ] 程式碼減少: **165-220 行** (從 1977 行 → 約 1757-1812 行)
- [ ] DatabaseHelper 使用率: **15+ 處**
- [ ] 消除資料庫連線重複: **12 處**
- [ ] 消除檔案存在性檢查重複: **3 處**
- [ ] 編譯成功，0 警告 0 錯誤
- [ ] 所有功能測試通過

### 最終文件更新
- [ ] 更新重構計畫.md 的「執行記錄」章節
- [ ] 記錄實際程式碼行數變化
- [ ] 記錄實際改寫的方法數量
- [ ] 記錄遇到的問題與解決方案
