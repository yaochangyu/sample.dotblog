# 快取實作計畫

## 目標
建立一個完整的快取實作範例，包含：
- Server side cache - 一級快取 (Memory Cache)
- Server side cache - 二級快取 (Redis Cache)
- Client side cache - HTTP Cache

## 實作步驟

### [ ] 步驟 1：建立方案和專案結構
**說明**：使用 dotnet CLI 建立方案和 ASP.NET Core Web API 專案，作為快取範例的基礎架構。
**原因**：需要一個完整的專案結構來組織程式碼，並提供 API 端點來展示各種快取機制。

### [ ] 步驟 2：安裝必要的 NuGet 套件
**說明**：安裝以下套件：
- Microsoft.Extensions.Caching.Memory (Memory Cache)
- Microsoft.Extensions.Caching.StackExchangeRedis (Redis Cache)
- Swashbuckle.AspNetCore (Swagger 文件)
**原因**：這些套件提供快取功能的核心實作，並提供 API 文件介面方便測試。

### [ ] 步驟 3：設定 Redis 連線配置
**說明**：在 appsettings.json 中加入 Redis 連線字串配置，並在 Program.cs 註冊服務。
**原因**：Redis 需要連線配置才能運作，將配置外部化便於管理不同環境的設定。

### [ ] 步驟 4：實作 Memory Cache 服務
**說明**：建立 MemoryCacheService，封裝 IMemoryCache 的操作，提供 Get/Set/Remove 方法。
**原因**：將快取邏輯封裝成服務，符合單一職責原則，便於維護和測試。

### [ ] 步驟 5：實作 Redis Cache 服務
**說明**：建立 RedisCacheService，封裝 IDistributedCache 的操作，提供 Get/Set/Remove 方法。
**原因**：分散式快取需要獨立的服務層，與 Memory Cache 分離以便靈活使用。

### [ ] 步驟 6：實作二級快取策略
**說明**：建立 TwoLevelCacheService，整合 Memory Cache 和 Redis Cache，實作先查一級再查二級的邏輯。
**原因**：二級快取可以提升效能，先從快速的 Memory Cache 讀取，未命中時才查詢 Redis。

### [ ] 步驟 7：實作 HTTP Cache 回應標頭
**說明**：建立 CacheController，設定 ResponseCache 屬性和 Cache-Control、ETag 等 HTTP 標頭。
**原因**：HTTP Cache 可以減少伺服器負載，讓瀏覽器或 CDN 快取回應內容。

### [ ] 步驟 8：建立範例 API 端點
**說明**：建立以下端點展示不同快取機制：
- GET /api/cache/memory - 展示 Memory Cache
- GET /api/cache/redis - 展示 Redis Cache
- GET /api/cache/two-level - 展示二級快取
- GET /api/cache/http - 展示 HTTP Cache
**原因**：提供實際可測試的端點，展示各種快取機制的使用方式和效果。

### [ ] 步驟 9：建立 README 文件
**說明**：撰寫 README.md，說明專案結構、如何執行、如何測試各種快取機制。
**原因**：完整的文件可以幫助使用者理解專案架構和使用方式。

### [ ] 步驟 10：建立 Docker Compose 配置
**說明**：建立 docker-compose.yml，包含 Redis 服務，方便本地開發測試。
**原因**：提供簡單的方式啟動 Redis 服務，避免手動安裝配置。

## 技術選型
- .NET 8.0
- ASP.NET Core Web API
- Memory Cache (IMemoryCache)
- Redis Cache (IDistributedCache)
- HTTP Cache (ResponseCache, Cache-Control, ETag)

## 預期成果
一個完整的快取實作範例專案，包含完整的程式碼、文件和測試方式。
