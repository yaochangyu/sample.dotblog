# 深入探討 HTTP Client-Side Cache：從 RFC 9111 規範到實戰驗證

## 前言

在開發 Web 應用程式時，提到「快取」，大部分開發者第一時間會想到 Redis、Memory Cache 等伺服器端快取方案。但其實還有一個經常被忽略、卻極其重要的快取層級：**HTTP Client-Side Cache**。

試想一個情境：你的網站首頁 API 每次都回傳相同的導覽選單資料，但每次使用者重新整理頁面，瀏覽器都重新向伺服器請求，這不僅浪費網路流量、增加伺服器負載，也降低使用者體驗。

如果善用 HTTP Cache 機制，告訴瀏覽器「這個資源可以快取 60 秒」，那麼在這 60 秒內，瀏覽器完全不需要發送請求，直接從本地快取讀取，速度近乎瞬間。

本文將深入探討 HTTP Client-Side Cache 的運作原理，透過實際的程式碼與實驗，觀察各種 Cache-Control 指令的行為，並分享最佳實踐。

## HTTP Caching 標準：RFC 9111

HTTP Caching 的行為由 **[RFC 9111](https://datatracker.ietf.org/doc/html/rfc9111)** 規範定義（取代了舊的 RFC 7234）。這份規範詳細說明了快取的運作方式、HTTP 標頭定義，以及快取必須遵守的規則。

### Cache-Control 核心指令

RFC 9111 定義了兩大類 Cache-Control 指令：

**Response Directives（回應指令）** - 伺服器告訴快取如何處理回應：

- **max-age=N** - 回應在 N 秒內被視為新鮮（fresh）
- **no-cache** - 快取必須在使用前向伺服器驗證
- **no-store** - 完全禁止快取儲存請求或回應
- **private** - 只允許瀏覽器快取，禁止 CDN 等共享快取
- **public** - 明確允許任何快取儲存回應
- **must-revalidate** - 過期後必須重新驗證，不能使用過期快取
- **immutable** - 內容在 max-age 期間永不改變（RFC 8246 擴展）

**Request Directives（請求指令）** - 客戶端告訴快取如何處理請求：

- **no-cache** - 要求在使用前向伺服器驗證
- **no-store** - 禁止快取儲存
- **max-age=N** - 客戶端希望回應的年齡不超過 N 秒

### 驗證機制

除了 Cache-Control，RFC 9111 還定義了條件請求機制：

- **ETag / If-None-Match** - 使用實體標籤進行精確比對
- **Last-Modified / If-Modified-Since** - 使用修改時間進行比對

## 實驗環境建置

為了深入理解這些指令的實際行為，我建立了一個 ASP.NET Core 實驗專案，實作 20 個測試端點，每個端點展示不同的 Cache-Control 行為。

### 專案結構

```
Lab.HttpCache/
├── src/Lab.HttpCache.Api/
│   ├── Controllers/
│   │   └── ClientCacheController.cs    # HTTP Client Cache 實驗端點
│   ├── Models/
│   │   └── Article.cs                  # 文章模型
│   ├── Repositories/
│   │   └── ArticleRepository.cs        # 文章倉儲（使用 HybridCache）
│   └── Program.cs
└── docker-compose.yml                   # Redis 服務
```

### 快速啟動

**1. 啟動 Redis：**

```bash
docker-compose up -d
```

**2. 啟動 Web API：**

```bash
cd src\Lab.HttpCache.Api
dotnet run
```

## 實驗一：max-age - 標準快取行為

### 端點實作

```csharp
[HttpGet("max-age")]
public IActionResult GetMaxAge([FromQuery] int seconds = 60)
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    Response.Headers.CacheControl = $"public, max-age={seconds}";

    return Ok(new
    {
        requestId,
        timestamp = DateTime.UtcNow,
        value = $"此回應可快取 {seconds} 秒",
        cacheControl = $"public, max-age={seconds}"
    });
}
```

### 測試腳本

建立測試檔案 `client-cache-test.http`：

```http
### 實驗一：max-age - 標準快取行為
@baseUrl = http://localhost:5178

### 1-1. 首次請求（會到達伺服器）
GET {{baseUrl}}/api/clientcache/max-age?seconds=60
Accept: application/json

### 1-2. 立即再次請求（60秒內，瀏覽器會使用快取，此請求不會到達伺服器）
# 注意：在 HTTP 檔案中測試，每次都會發送請求
# 要觀察瀏覽器快取行為，請在瀏覽器中測試
GET {{baseUrl}}/api/clientcache/max-age?seconds=60
Accept: application/json

### 1-3. 查看總請求數（驗證快取是否有效）
GET {{baseUrl}}/api/clientcache/stats
Accept: application/json
```

### 實驗步驟與觀察

**Step 1：執行首次請求**

在 Visual Studio Code 或 Visual Studio 中點擊「Send Request」。

**回應範例：**

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=60
Content-Type: application/json

{
  "requestId": 1,
  "timestamp": "2026-01-08T05:23:45.678Z",
  "value": "此回應可快取 60 秒",
  "cacheControl": "public, max-age=60"
}
```

**觀察重點：**
- `requestId: 1` - 這是第一次請求
- `Cache-Control: public, max-age=60` - 告訴瀏覽器可以快取 60 秒

**Step 2：在瀏覽器中測試快取行為**

開啟 Chrome DevTools（F12） → Network 分頁，訪問：
```
http://localhost:5178/api/clientcache/max-age?seconds=60
```

在 60 秒內按 F5 重新整理，你會看到：
- **Status**: `200 OK (from disk cache)` 或 `(from memory cache)`
- **Size**: `(disk cache)` 或 `(memory cache)`
- **Time**: 近乎 0ms

這表示瀏覽器完全沒有發送請求到伺服器，直接使用本地快取。

**應用場景：**
- 靜態資源（CSS、JS、圖片）
- 不常變動的 API 回應（產品分類、導覽選單）

## 實驗二：no-store - 完全禁止快取

### 端點實作

```csharp
[HttpGet("no-store")]
public IActionResult GetNoStore()
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    Response.Headers.CacheControl = "no-store";

    return Ok(new { requestId, timestamp = DateTime.UtcNow });
}
```

### 測試腳本

```http
### 實驗二：no-store - 完全禁止快取

### 2-1. 首次請求
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json

### 2-2. 立即再次請求（每次都會到達伺服器）
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json

### 2-3. 第三次請求（觀察 requestId 持續增加）
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json
```

### 實驗觀察

執行三次請求後，觀察 `requestId` 的變化：

```json
// 第一次
{"requestId": 2, "timestamp": "2026-01-08T05:25:10.123Z"}

// 第二次
{"requestId": 3, "timestamp": "2026-01-08T05:25:12.456Z"}

// 第三次
{"requestId": 4, "timestamp": "2026-01-08T05:25:14.789Z"}
```

**觀察重點：**
- `requestId` 持續遞增，表示每次請求都到達伺服器
- `timestamp` 不同，表示每次都重新生成回應
- 瀏覽器不會儲存任何快取

**應用場景：**
- 敏感資料（使用者個資、金融資料）
- 即時性要求極高的資料（股票價格、聊天訊息）

## 實驗三：ETag 驗證與 304 Not Modified

### 端點實作

```csharp
[HttpGet("article/{id}")]
public IActionResult GetArticle(int id)
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    var article = _repository.GetArticle(id);

    if (article == null)
    {
        return NotFound();
    }

    // 使用 UpdatedAt.Ticks 生成 ETag
    var etag = $"\"{article.UpdatedAt.Ticks}\"";

    Response.Headers.CacheControl = "public, max-age=60, must-revalidate";
    Response.Headers.ETag = etag;

    // 檢查條件請求
    if (Request.Headers.IfNoneMatch == etag)
    {
        return StatusCode(304); // Not Modified
    }

    return Ok(article);
}
```

### 測試腳本

```http
### 實驗三：ETag 驗證機制

### 3-1. 首次請求文章（記下回應中的 ETag 值）
GET {{baseUrl}}/api/clientcache/article/1
Accept: application/json

### 3-2. 使用 ETag 進行條件請求（模擬 60 秒後瀏覽器的行為）
# 將下面的 ETag 值替換為步驟 3-1 回應中的實際值
GET {{baseUrl}}/api/clientcache/article/1
Accept: application/json
If-None-Match: "638734982345678901"

### 3-3. 更新文章（會改變 ETag）
PUT {{baseUrl}}/api/clientcache/article/1
Content-Type: application/json

{
  "title": "更新後的標題",
  "content": "更新後的內容"
}

### 3-4. 使用舊 ETag 再次請求（會收到新資料）
GET {{baseUrl}}/api/clientcache/article/1
Accept: application/json
If-None-Match: "638734982345678901"
```

### 實驗步驟與觀察

**Step 1：首次請求**

執行 3-1，回應範例：

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=60, must-revalidate
ETag: "638734982345678901"
Content-Type: application/json

{
  "requestId": 5,
  "article": {
    "id": 1,
    "title": "深入探討 HTTP Client-Side Cache",
    "content": "...",
    "updatedAt": "2026-01-07T10:30:45.678Z"
  }
}
```

**Step 2：條件請求（ETag 匹配）**

執行 3-2，回應範例：

```http
HTTP/1.1 304 Not Modified
Cache-Control: public, max-age=60, must-revalidate
ETag: "638734982345678901"
```

**觀察重點：**
- 狀態碼：`304 Not Modified`
- **沒有 body**，只有標頭（大約 200 bytes）
- 流量節省：相比完整回應（可能數 KB），節省了 **99%** 以上

**Step 3：更新文章**

執行 3-3，回應範例：

```json
{
  "requestId": 6,
  "message": "文章已更新",
  "newETag": "638735092456789012",
  "article": {
    "id": 1,
    "title": "更新後的標題",
    "content": "更新後的內容",
    "updatedAt": "2026-01-08T05:30:15.123Z"
  }
}
```

注意 `newETag` 已經改變。

**Step 4：使用舊 ETag 請求**

執行 3-4，回應範例：

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=60, must-revalidate
ETag: "638735092456789012"
Content-Type: application/json

{
  "requestId": 7,
  "article": {
    "id": 1,
    "title": "更新後的標題",
    "content": "更新後的內容"
  }
}
```

**觀察重點：**
- ETag 不匹配，伺服器回傳 **200 OK** 和完整資料
- 確保使用者永遠能看到最新的內容

## 實驗四：no-cache vs no-store 的差異

這是一個常見的誤區。

### 測試腳本

```http
### 實驗四：no-cache vs no-store

### 4-1. no-cache - 可以快取，但必須驗證
GET {{baseUrl}}/api/clientcache/no-cache
Accept: application/json

### 4-2. 立即再次請求 no-cache（會發送條件請求）
GET {{baseUrl}}/api/clientcache/no-cache
Accept: application/json

### 4-3. no-store - 完全不快取
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json

### 4-4. 立即再次請求 no-store（每次都完整執行）
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json
```

### 實驗觀察

**no-cache 行為：**

首次請求：
```http
HTTP/1.1 200 OK
Cache-Control: no-cache
ETag: "8"

{"requestId": 8, "timestamp": "..."}
```

第二次請求（瀏覽器會自動加上 If-None-Match）：
```http
HTTP/1.1 304 Not Modified
Cache-Control: no-cache
ETag: "8"
```

**no-store 行為：**

每次請求都是完整的 200 回應，`requestId` 持續遞增。

**關鍵差異：**

| 指令 | 是否快取 | 是否驗證 | 流量消耗 |
|------|---------|---------|---------|
| `no-cache` | ✅ 可以快取 | ✅ 每次必須驗證 | 低（304 回應很小） |
| `no-store` | ❌ 不可快取 | ❌ 無需驗證（每次完整請求） | 高（每次完整回應） |

## 實驗五：immutable - 靜態資源的終極優化

### 測試腳本

```http
### 實驗五：immutable - 永不改變的資源

### 5-1. 請求 immutable 資源
GET {{baseUrl}}/api/clientcache/immutable
Accept: application/json

### 5-2. 即使手動重新整理，也不會發送驗證請求
# 在瀏覽器中按 F5，觀察 Network 面板
GET {{baseUrl}}/api/clientcache/immutable
Accept: application/json
```

### 端點實作

```csharp
[HttpGet("immutable")]
public IActionResult GetImmutable()
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    Response.Headers.CacheControl = "public, max-age=31536000, immutable";

    return Ok(new
    {
        requestId,
        timestamp = DateTime.UtcNow,
        cacheControl = "public, max-age=31536000, immutable"
    });
}
```

### 實驗觀察

**第一次請求：**
```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=31536000, immutable

{"requestId": 12}
```

**在一年內的任何重新整理：**
- 瀏覽器直接使用快取
- **即使按 Ctrl+F5 強制重新整理**，支援 `immutable` 的瀏覽器也不會發送請求

**應用場景：**
- 帶版本號的靜態資源：`app.v1.2.3.js`、`logo-abc123.png`
- 使用 content hash 命名的檔案：`main.a3f2d1b.css`

**最佳實踐：**
```html
<!-- 正確：帶版本號 + immutable -->
<script src="/static/app.v1.2.3.js"></script>
<!-- Cache-Control: public, max-age=31536000, immutable -->

<!-- 錯誤：沒有版本號，不應使用 immutable -->
<script src="/static/app.js"></script>
```

## 實驗六：stale-while-revalidate - 提升使用者體驗

### 測試腳本

```http
### 實驗六：stale-while-revalidate - 背景重新驗證

### 6-1. 首次請求
GET {{baseUrl}}/api/clientcache/stale-while-revalidate
Accept: application/json

### 6-2. 等待 15 秒後再次請求
# max-age=10，10秒後過期
# stale-while-revalidate=60，過期後60秒內可以立即回傳快取，同時背景重新驗證
GET {{baseUrl}}/api/clientcache/stale-while-revalidate
Accept: application/json
```

### 端點實作

```csharp
[HttpGet("stale-while-revalidate")]
public IActionResult GetStaleWhileRevalidate()
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    Response.Headers.CacheControl = "max-age=10, stale-while-revalidate=60";

    return Ok(new { requestId, timestamp = DateTime.UtcNow });
}
```

### 實驗觀察

**時間軸分析：**

```
t=0s:   首次請求 → requestId: 13
t=5s:   再次請求 → 使用快取（不發送請求）
t=12s:  再次請求 → 過期，但立即回傳快取（requestId 仍是 13）
                  → 同時背景發送請求更新快取
t=15s:  再次請求 → 使用背景更新的快取（requestId 可能變成 14）
```

**優點：**
- 使用者感知延遲接近 0
- 即使快取過期，也能立即回應
- 背景自動更新快取

**應用場景：**
- 社群網站的貼文列表
- 新聞網站的文章清單
- 電商網站的產品推薦

## 實驗七：Vary 標頭 - 內容協商

### 測試腳本

```http
### 實驗七：Vary - 根據請求標頭快取不同版本

### 7-1. 使用不同的 Accept-Encoding
GET {{baseUrl}}/api/clientcache/vary
Accept: application/json
Accept-Encoding: gzip

### 7-2. 使用不同的 Accept-Encoding（會產生不同的快取）
GET {{baseUrl}}/api/clientcache/vary
Accept: application/json
Accept-Encoding: br

### 7-3. 使用不同的 User-Agent（也會產生不同的快取）
GET {{baseUrl}}/api/clientcache/vary
Accept: application/json
User-Agent: Mozilla/5.0 (Mobile)
```

### 端點實作

```csharp
[HttpGet("vary")]
public IActionResult GetVary()
{
    var requestId = Interlocked.Increment(ref _requestCounter);
    var acceptEncoding = Request.Headers.AcceptEncoding.FirstOrDefault() ?? "none";

    Response.Headers.CacheControl = "public, max-age=60";
    Response.Headers.Vary = "Accept-Encoding, User-Agent";

    return Ok(new { requestId, acceptEncoding });
}
```

### 實驗觀察

執行上述三個請求，觀察 `requestId`：

```json
// 7-1: gzip
{"requestId": 15, "acceptEncoding": "gzip"}

// 7-2: br （不同的 Accept-Encoding，產生新的快取）
{"requestId": 16, "acceptEncoding": "br"}

// 7-3: Mobile User-Agent （不同的 User-Agent，又產生新的快取）
{"requestId": 17, "acceptEncoding": "gzip"}
```

**關鍵概念：**
- `Vary` 告訴快取：不同的請求標頭值 = 不同的快取項目
- 每個不同的標頭組合都會產生獨立的快取

**注意事項：**
- 過多的 `Vary` 標頭會降低快取命中率
- 只對真正會影響回應內容的標頭使用 `Vary`

## 多層快取架構

實際專案中，我們會結合客戶端快取與伺服器端快取，形成多層快取架構：

```
┌─────────────────────────────────────┐
│   L1: 瀏覽器快取                     │
│   - Cache-Control: max-age=60       │
│   - 60 秒內完全不發送請求            │
└─────────────────────────────────────┘
              ↓ (60秒後)
┌─────────────────────────────────────┐
│   條件請求 (If-None-Match)          │
│   - 如果 ETag 匹配 → 304            │
│   - 如果 ETag 不匹配 → 200 + 新資料 │
└─────────────────────────────────────┘
              ↓ (ETag 不匹配)
┌─────────────────────────────────────┐
│   L2: HybridCache (Memory)          │
│   - 快取時間: 1 分鐘                │
│   - 極快的讀取速度 (~1ms)           │
└─────────────────────────────────────┘
              ↓ (Memory 快取過期)
┌─────────────────────────────────────┐
│   L3: HybridCache (Redis)           │
│   - 快取時間: 5 分鐘                │
│   - 跨伺服器共享 (~5ms)             │
└─────────────────────────────────────┘
              ↓ (Redis 快取過期)
┌─────────────────────────────────────┐
│   L4: 資料庫                        │
│   - 最終資料來源 (~10-50ms)         │
└─────────────────────────────────────┘
```

### 效能分析

假設一個 API：
- 回應大小：5 KB
- 每秒請求數：100 req/s
- 資料庫查詢時間：10ms

**沒有快取：**
- 每秒流量：500 KB/s
- 資料庫查詢：100 req/s

**使用多層快取（假設快取命中率）：**
- 60% 請求在瀏覽器快取內 → 0 KB/s，不到達伺服器
- 30% 請求使用 304 回應 → 6 KB/s (0.2 KB × 30)
- 10% 請求需要完整回應 → 50 KB/s (5 KB × 10)

**總流量：56 KB/s（節省 88.8%）**
**資料庫查詢：1 req/s（降低 99%）**

## ResponseCache Attribute

ASP.NET Core 提供了 `ResponseCacheAttribute`，簡化快取設定：

```csharp
// 方式一：使用 Attribute
[ResponseCache(Duration = 60, Location = ResponseCacheLocation.Any)]
[HttpGet("products/{id}")]
public IActionResult GetProduct(int id)
{
    // 等同於設定 Cache-Control: public, max-age=60
    return Ok(product);
}

// 方式二：手動設定標頭（更靈活）
[HttpGet("articles/{id}")]
public IActionResult GetArticle(int id)
{
    var article = _repository.GetArticle(id);
    var etag = $"\"{article.UpdatedAt.Ticks}\"";

    Response.Headers.CacheControl = "public, max-age=60, must-revalidate";
    Response.Headers.ETag = etag;

    if (Request.Headers.IfNoneMatch == etag)
    {
        return StatusCode(304);
    }

    return Ok(article);
}
```

### ResponseCache 參數說明

```csharp
[ResponseCache(
    Duration = 60,                          // max-age=60
    Location = ResponseCacheLocation.Any,   // public
    VaryByHeader = "Accept-Encoding",       // Vary: Accept-Encoding
    VaryByQueryKeys = new[] { "page" }      // 根據 query string 快取
)]
```

**Location 選項：**
- `Any` → `public` (任何快取都可以儲存)
- `Client` → `private` (只有瀏覽器可以快取)
- `None` → `no-store, no-cache` (不快取)

## 最佳實踐建議

### 1. 根據資料特性選擇策略

**靜態資源（CSS、JS、圖片）：**
```csharp
Response.Headers.CacheControl = "public, max-age=31536000, immutable";
// 搭配版本號：app.v1.2.3.js
```

**半靜態資料（文章內容）：**
```csharp
Response.Headers.CacheControl = "public, max-age=300, must-revalidate";
Response.Headers.ETag = $"\"{article.UpdatedAt.Ticks}\"";
```

**使用者特定資料（個人資訊）：**
```csharp
Response.Headers.CacheControl = "private, max-age=60";
```

**敏感資料（金融交易）：**
```csharp
Response.Headers.CacheControl = "no-store";
```

### 2. 務必處理條件請求

**不完整的實作（錯誤）：**
```csharp
[HttpGet("data")]
public IActionResult GetData()
{
    Response.Headers.ETag = "\"v1.0\"";
    return Ok(data); // 每次都回傳完整資料！
}
```

**完整的實作（正確）：**
```csharp
[HttpGet("data")]
public IActionResult GetData()
{
    var etag = "\"v1.0\"";
    Response.Headers.ETag = etag;

    if (Request.Headers.IfNoneMatch == etag)
    {
        return StatusCode(304); // 節省流量
    }

    return Ok(data);
}
```

### 3. 避免過度快取動態內容

**危險的設定（錯誤）：**
```csharp
[HttpGet("cart")]
public IActionResult GetCart()
{
    Response.Headers.CacheControl = "public, max-age=3600"; // 錯誤！
    return Ok(userCart); // 使用者A的購物車可能被CDN快取並回傳給使用者B
}
```

**正確做法：**
```csharp
[HttpGet("cart")]
public IActionResult GetCart()
{
    Response.Headers.CacheControl = "private, no-store";
    return Ok(userCart);
}
```

### 4. 開發環境 vs 生產環境

```csharp
if (app.Environment.IsDevelopment())
{
    // 開發時禁用快取
    app.Use(async (context, next) =>
    {
        context.Response.Headers.CacheControl = "no-store";
        await next();
    });
}
else
{
    // 生產環境啟用快取
    app.UseResponseCaching();
}
```

## 常見誤區

### 誤區 1：no-cache = 不快取

❌ **錯誤認知：**
```
no-cache = 完全不快取
```

✅ **正確理解：**
```
no-cache  = 可以快取，但必須驗證
no-store  = 完全不快取
```

### 誤區 2：只設定 ETag 而不處理條件請求

這會導致每次都傳輸完整資料，失去 ETag 的意義。

### 誤區 3：使用 immutable 於會改變的資源

```csharp
// 錯誤：API 資料會改變，不應使用 immutable
Response.Headers.CacheControl = "immutable, max-age=86400";
```

`immutable` 只適用於永不改變的資源，通常搭配版本號或 content hash。

## 完整測試腳本

將以下內容儲存為 `client-cache-complete.http`：

```http
@baseUrl = http://localhost:5178

### ========== 實驗一：max-age ==========
### 標準快取，60秒內瀏覽器直接使用快取
GET {{baseUrl}}/api/clientcache/max-age?seconds=60
Accept: application/json

###

### ========== 實驗二：no-store ==========
### 完全禁止快取，每次都完整執行
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json

###

### ========== 實驗三：ETag 驗證 ==========
### 3-1. 首次請求文章
GET {{baseUrl}}/api/clientcache/article/1
Accept: application/json

### 3-2. 條件請求（替換為實際的 ETag）
GET {{baseUrl}}/api/clientcache/article/1
Accept: application/json
If-None-Match: "638734982345678901"

### 3-3. 更新文章
PUT {{baseUrl}}/api/clientcache/article/1
Content-Type: application/json

{
  "title": "實驗：更新文章標題",
  "content": "實驗：更新文章內容"
}

###

### ========== 實驗四：no-cache vs no-store ==========
### 4-1. no-cache（會快取但必須驗證）
GET {{baseUrl}}/api/clientcache/no-cache
Accept: application/json

### 4-2. no-store（完全不快取）
GET {{baseUrl}}/api/clientcache/no-store
Accept: application/json

###

### ========== 實驗五：immutable ==========
### 永不改變的資源，瀏覽器不會發送驗證請求
GET {{baseUrl}}/api/clientcache/immutable
Accept: application/json

###

### ========== 實驗六：stale-while-revalidate ==========
### 過期後立即回傳快取，背景重新驗證
GET {{baseUrl}}/api/clientcache/stale-while-revalidate
Accept: application/json

###

### ========== 實驗七：Vary ==========
### 7-1. 不同的 Accept-Encoding
GET {{baseUrl}}/api/clientcache/vary
Accept: application/json
Accept-Encoding: gzip

### 7-2. 不同的 Accept-Encoding
GET {{baseUrl}}/api/clientcache/vary
Accept: application/json
Accept-Encoding: br

###

### ========== 實驗八：組合測試 ==========
### Cache-Control + ETag + Last-Modified
GET {{baseUrl}}/api/clientcache/combined
Accept: application/json

###

### ========== 實驗九：文章列表 ==========
### 取得所有文章（快取 5 分鐘）
GET {{baseUrl}}/api/clientcache/articles
Accept: application/json

###

### ========== 統計資訊 ==========
### 查看總請求數
GET {{baseUrl}}/api/clientcache/stats
Accept: application/json

### 重置計數器
POST {{baseUrl}}/api/clientcache/reset
Accept: application/json

###
```

## 總結

HTTP Client-Side Cache 是一個強大但經常被忽視的效能優化工具。透過本文的實驗，我們驗證了：

1. **max-age** 是最基本也最有效的快取策略，可以大幅降低伺服器負載
2. **ETag** 提供精確的驗證機制，透過 304 回應節省 99% 的流量
3. **immutable** 是靜態資源的終極優化，完全消除驗證請求
4. **no-cache** 不等於不快取，它表示「必須驗證」
5. **stale-while-revalidate** 在效能和新鮮度之間取得平衡
6. **Vary** 確保內容協商的正確性

記住，快取是一把雙面刃：正確使用能帶來巨大的效能提升，錯誤使用可能導致使用者看到過時的資料。始終根據資料的特性（敏感性、變動頻率、即時性要求）來選擇合適的快取策略。

透過這次實驗，我深刻體會到 `requestId` 的價值——它清楚地顯示哪些請求真正到達伺服器，哪些被快取攔截。這種可觀察性對於理解和驗證快取行為至關重要。

最重要的是，HTTP Cache 是**標準化**的，不需要額外的程式庫或框架，只需要正確設定 HTTP 標頭，就能獲得瀏覽器和 CDN 的原生支援。

若有謬誤，煩請告知，謝謝。

## 參考資源

- [RFC 9111: HTTP Caching](https://datatracker.ietf.org/doc/html/rfc9111)
- [RFC 8246: HTTP Immutable Responses](https://datatracker.ietf.org/doc/html/rfc8246)
- [RFC 5861: HTTP Cache-Control Extensions for Stale Content](https://datatracker.ietf.org/doc/html/rfc5861)
- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)
- [完整實驗程式碼](./src/Lab.HttpCache.Api)
